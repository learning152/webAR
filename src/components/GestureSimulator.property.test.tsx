/**
 * Property-based tests for GestureSimulator component
 * Tests universal properties that should hold across all inputs
 */

import { describe, it, expect } from 'vitest';
import { render, screen, fireEvent } from '@testing-library/react';
import { GestureSimulator } from './GestureSimulator';
import { ShapeType } from '../shapes/ShapeGenerator';
import { getAllShapeTypes } from '../config/shapeConfig';
import * as fc from 'fast-check';

/**
 * Feature: gesture-simulator-fallback, Property 1: 形态按钮数量与枚举值一致
 * 
 * For any ShapeType enum, the number of shape buttons generated by the gesture simulator
 * should equal the number of values in the enum.
 * 
 * Validates: Requirements 2.1, 6.1
 */
describe('Property 1: Shape button count matches enum values', () => {
  it('should generate exactly one button for each ShapeType enum value', () => {
    fc.assert(
      fc.property(
        // Generate a random current shape
        fc.constantFrom(...Object.values(ShapeType)),
        (currentShape) => {
          // Get all shape types from the enum
          const allShapeTypes = getAllShapeTypes();
          const expectedCount = allShapeTypes.length;

          // Render the component
          const { container } = render(
            <GestureSimulator
              visible={true}
              currentShape={currentShape}
              onShapeChange={() => {}}
              onRotationChange={() => {}}
              onScaleChange={() => {}}
            />
          );

          // Count the number of shape buttons rendered
          const shapeButtons = container.querySelectorAll('.shape-button');
          const actualCount = shapeButtons.length;

          // Property: button count should equal enum value count
          expect(actualCount).toBe(expectedCount);
        }
      ),
      { numRuns: 100 }
    );
  });

  it('should have a button for every ShapeType enum value', () => {
    fc.assert(
      fc.property(
        fc.constantFrom(...Object.values(ShapeType)),
        (currentShape) => {
          const allShapeTypes = getAllShapeTypes();

          const { container } = render(
            <GestureSimulator
              visible={true}
              currentShape={currentShape}
              onShapeChange={() => {}}
              onRotationChange={() => {}}
              onScaleChange={() => {}}
            />
          );

          // Count unique buttons - each shape type should have exactly one button
          const buttons = container.querySelectorAll('.shape-button');
          
          // Property: number of buttons should equal number of shape types
          expect(buttons.length).toBe(allShapeTypes.length);
          
          // Property: each button should be unique (no duplicates)
          const buttonTexts = Array.from(buttons).map(b => b.textContent);
          const uniqueTexts = new Set(buttonTexts);
          expect(uniqueTexts.size).toBe(buttons.length);
        }
      ),
      { numRuns: 100 }
    );
  });
});

/**
 * Feature: gesture-simulator-fallback, Property 2: 形态按钮点击触发正确的形态转换
 * 
 * For any shape type, clicking the corresponding shape button should trigger
 * the transformation to that shape, and the current shape state should update
 * to the clicked shape.
 * 
 * Validates: Requirements 2.3, 2.4
 */
describe('Property 2: Shape button click triggers correct transformation', () => {
  it('should call onShapeChange with the correct shape type when any button is clicked', () => {
    fc.assert(
      fc.property(
        // Generate two random shapes: one for current, one for target
        fc.constantFrom(...Object.values(ShapeType)),
        fc.constantFrom(...Object.values(ShapeType)),
        (currentShape, targetShape) => {
          let capturedShape: ShapeType | null = null;
          
          const handleShapeChange = (shape: ShapeType) => {
            capturedShape = shape;
          };

          const { container } = render(
            <GestureSimulator
              visible={true}
              currentShape={currentShape}
              onShapeChange={handleShapeChange}
              onRotationChange={() => {}}
              onScaleChange={() => {}}
            />
          );

          // Find the button for the target shape
          const buttons = container.querySelectorAll('.shape-button');
          const allShapeTypes = getAllShapeTypes();
          const targetIndex = allShapeTypes.indexOf(targetShape);
          
          // Click the button
          const targetButton = buttons[targetIndex] as HTMLElement;
          targetButton.click();

          // Property: callback should be called with the target shape
          expect(capturedShape).toBe(targetShape);
        }
      ),
      { numRuns: 100 }
    );
  });

  it('should highlight the active shape button correctly', () => {
    fc.assert(
      fc.property(
        fc.constantFrom(...Object.values(ShapeType)),
        (currentShape) => {
          const { container } = render(
            <GestureSimulator
              visible={true}
              currentShape={currentShape}
              onShapeChange={() => {}}
              onRotationChange={() => {}}
              onScaleChange={() => {}}
            />
          );

          const buttons = container.querySelectorAll('.shape-button');
          const allShapeTypes = getAllShapeTypes();
          const currentIndex = allShapeTypes.indexOf(currentShape);

          // Property: exactly one button should have the 'active' class
          const activeButtons = container.querySelectorAll('.shape-button.active');
          expect(activeButtons.length).toBe(1);

          // Property: the active button should be the one corresponding to currentShape
          const activeButton = buttons[currentIndex];
          expect(activeButton.classList.contains('active')).toBe(true);
        }
      ),
      { numRuns: 100 }
    );
  });
});

/**
 * Feature: gesture-simulator-fallback, Property 5: 缩放过渡平滑性
 * 
 * For any scale value change, intermediate frame scale values should be
 * between the start and target values, implementing smooth interpolation.
 * 
 * Note: This property tests the scale mapping function rather than animation frames,
 * as React component testing doesn't easily capture animation interpolation.
 * We verify that the scale mapping is monotonic and bounded.
 * 
 * Validates: Requirements 4.3
 */
describe('Property 5: Scale transition smoothness', () => {
  it('should map slider values monotonically to scale values', () => {
    fc.assert(
      fc.property(
        // Generate two slider values
        fc.integer({ min: 0, max: 100 }),
        fc.integer({ min: 0, max: 100 }),
        (value1, value2) => {
          const MIN_SCALE = 0.5;
          const MAX_SCALE = 2.0;
          
          // Map slider value to scale
          const sliderToScale = (value: number): number => {
            return MIN_SCALE + (value / 100) * (MAX_SCALE - MIN_SCALE);
          };

          const scale1 = sliderToScale(value1);
          const scale2 = sliderToScale(value2);

          // Property 1: Scale values should be within bounds
          expect(scale1).toBeGreaterThanOrEqual(MIN_SCALE);
          expect(scale1).toBeLessThanOrEqual(MAX_SCALE);
          expect(scale2).toBeGreaterThanOrEqual(MIN_SCALE);
          expect(scale2).toBeLessThanOrEqual(MAX_SCALE);

          // Property 2: Monotonic mapping - if value1 < value2, then scale1 <= scale2
          if (value1 < value2) {
            expect(scale1).toBeLessThanOrEqual(scale2);
          } else if (value1 > value2) {
            expect(scale1).toBeGreaterThanOrEqual(scale2);
          } else {
            expect(scale1).toBe(scale2);
          }
        }
      ),
      { numRuns: 100 }
    );
  });

  it('should produce intermediate scale values between start and target', () => {
    fc.assert(
      fc.property(
        fc.integer({ min: 0, max: 100 }),
        fc.integer({ min: 0, max: 100 }),
        fc.integer({ min: 1, max: 99 }), // Interpolation factor (percentage)
        (startValue, endValue, interpPercent) => {
          // Skip if start and end are the same
          if (startValue === endValue) {
            return true;
          }

          const MIN_SCALE = 0.5;
          const MAX_SCALE = 2.0;
          
          const sliderToScale = (value: number): number => {
            return MIN_SCALE + (value / 100) * (MAX_SCALE - MIN_SCALE);
          };

          const startScale = sliderToScale(startValue);
          const endScale = sliderToScale(endValue);
          
          // Calculate intermediate slider value
          const interpValue = startValue + (endValue - startValue) * (interpPercent / 100);
          const interpScale = sliderToScale(interpValue);

          // Property: Intermediate scale should be between start and end
          const minScale = Math.min(startScale, endScale);
          const maxScale = Math.max(startScale, endScale);
          
          expect(interpScale).toBeGreaterThanOrEqual(minScale - 0.001); // Small epsilon for floating point
          expect(interpScale).toBeLessThanOrEqual(maxScale + 0.001);
        }
      ),
      { numRuns: 100 }
    );
  });

  it('should call onScaleChange with bounded scale values', () => {
    fc.assert(
      fc.property(
        fc.constantFrom(...Object.values(ShapeType)),
        fc.integer({ min: 0, max: 100 }).filter(v => v !== 50), // Exclude initial value
        (currentShape, sliderValue) => {
          let capturedScale: number | null = null;
          
          const handleScaleChange = (scale: number) => {
            capturedScale = scale;
          };

          const { container } = render(
            <GestureSimulator
              visible={true}
              currentShape={currentShape}
              onShapeChange={() => {}}
              onRotationChange={() => {}}
              onScaleChange={handleScaleChange}
            />
          );

          // Find the scale slider
          const slider = container.querySelector('.scale-slider') as HTMLInputElement;
          expect(slider).not.toBeNull();

          // Simulate slider change using fireEvent which properly handles React events
          fireEvent.change(slider, { target: { value: sliderValue.toString() } });

          // Property: Scale should be within bounds
          // Note: The new scale system supports multipliers (1x, 3x, 5x)
          // Base range is 0.3-2.0 at 1x multiplier (default)
          // Maximum range is 1.5-10.0 at 5x multiplier
          expect(capturedScale).not.toBeNull();
          expect(capturedScale!).toBeGreaterThanOrEqual(0.3); // BASE_MIN_SCALE * 1
          expect(capturedScale!).toBeLessThanOrEqual(10.0);   // BASE_MAX_SCALE * 5
        }
      ),
      { numRuns: 100 }
    );
  });
});
